[["data-products-1.html", "Chapter 8 Data products 8.1 Introduction 8.2 A first taste of Quarto 8.3 Other output formats 8.4 Interactive web applications with {shiny} 8.5 How to build data products using {targets}", " Chapter 8 Data products What you’ll have learned by the end of the chapter: you’ll know how to build data products using Quarto and Shiny. 8.1 Introduction We are going to start by building data products using Quarto. Quarto is a tool created by Posit, the company behind RStudio and Shiny. Quarto leverages pandoc to convert between many document formats (for example, from .md to .docx) and makes it possible to embed R, Python, Julia and Observable JS code into documents. It is not an R-specific tool, so it is a program that you must install on your computer. So go to this link and download and install Quarto. We are going to start simple, with “static” data products. By static I mean products without any sort of interactivity, so the user can look at them, read them, but not change them in any way. These products are essentially going to be documents in the .docx, .pptx and .pdf formats, but also .html. Thanks to Quarto, it is thus possible to programmatically create documents. 8.2 A first taste of Quarto A Quarto file looks very close to a standard Markdown file. So if you know Markdown, you will not have many problems to switch to Quarto. If you don’t know Markdown, no worries, its syntax is quite simple and can be very quickly picked up. Let’s start with a basic Quarto source. Open your favorite text editor (doesn’t have to be RStudio) and create a file called example.qmd and copy the following lines in it: --- title: &quot;My Title&quot; author: &quot;My name&quot; date: today --- ## This is a simple quarto document ```{r} n &lt;- 10 rnorm(n) ``` This is the output. The first few lines of the document is where you can define the title of the document, the name of the author and the date. For the date, I’ve use the today keyword to get today’s date but you could use a string to set the date to a specific day (for example, “2022-10-28”). The content in the document consists of a level 2 title (## This is a simple quarto document) and of an R code chunk. Code chunks is were you will write code that gets then evaluated at render (compile) time. To compile this file, run the following inside a terminal: ➤ quarto render example.qmd If you’re inside RStudio, you can also render the document by pressing CTRL-SHIFT-K or run the command: quarto::quarto_render(&quot;example.qmd&quot;) There are various ways to integrate Quarto with different editors: VS Code RStudio Jupyter (Neo)Vim, Emacs, Sublime Once the file is done rendering, you should find an html file in the same folder. Open this html file inside a web browser and see the output. It is possible to run arbitrary R code inside the code chunks: --- title: &quot;My Title&quot; author: &quot;My name&quot; date: today --- ## This is a simple quarto document ```{r} library(dplyr) library(tidyr) library(purrr) library(ggplot2) library(myPackage) data(&quot;unemp&quot;) unemp %&gt;% janitor::clean_names() %&gt;% filter(level == &quot;Commune&quot;, place_name %in% c(&quot;Luxembourg&quot;, &quot;Esch-sur-Alzette&quot;, &quot;Wiltz&quot;)) %&gt;% group_by(place_name) %&gt;% nest() %&gt;% mutate(plots = map2(.x = data, .y = place_name, ~ggplot(data = .x) + theme_minimal() + geom_line(aes(year, unemployment_rate_in_percent, group = 1)) + labs(title = paste(&quot;Unemployment in&quot;, .y)))) %&gt;% pull(plots) ``` This is what the output looks like. As you can see, it is quite easy to create a document with potentially hundreds of plots using what we’ve learned until now. However, our document does not look great; for starters, we see the source code there, which we would like to hide. People that will read this document might not be interested in the source code, but only in the plots. The other issue is that when loading the {dplyr} package, users get some message informing them about some functions that get masked. We would like to hide all of this. It turns out that code chunks have options, and we can use them to hide source code and warning messages: --- title: &quot;My Title&quot; author: &quot;My name&quot; date: today --- ## This is a simple quarto document ```{r} #| echo: false #| warning: false library(dplyr) library(tidyr) library(purrr) library(ggplot2) library(myPackage) data(&quot;unemp&quot;) unemp %&gt;% janitor::clean_names() %&gt;% filter(level == &quot;Commune&quot;, place_name %in% c(&quot;Luxembourg&quot;, &quot;Esch-sur-Alzette&quot;, &quot;Wiltz&quot;)) %&gt;% group_by(place_name) %&gt;% nest() %&gt;% mutate(plots = map2(.x = data, .y = place_name, ~ggplot(data = .x) + theme_minimal() + geom_line(aes(year, unemployment_rate_in_percent, group = 1)) + labs(title = paste(&quot;Unemployment in&quot;, .y)))) %&gt;% pull(plots) ``` This is what the output looks like. Rendering this document will result in something nicer. We could also fold the code instead of completely removing it. This is useful if we need to send the document to collaborators who might be interested in the source code as well. However, code folding is something that only works in html outputs, and thus we need to specify the output format in the header of the document (look at the three new lines after we define the data), and also remove the echo: false option from the R chunk: --- title: &quot;My Title&quot; author: &quot;My name&quot; date: today format: html: code-fold: true --- ## This is a simple quarto document ```{r} #| warning: false library(dplyr) library(tidyr) library(purrr) library(ggplot2) library(myPackage) data(&quot;unemp&quot;) unemp %&gt;% janitor::clean_names() %&gt;% filter(level == &quot;Commune&quot;, place_name %in% c(&quot;Luxembourg&quot;, &quot;Esch-sur-Alzette&quot;, &quot;Wiltz&quot;)) %&gt;% group_by(place_name) %&gt;% nest() %&gt;% mutate(plots = map2(.x = data, .y = place_name, ~ggplot(data = .x) + theme_minimal() + geom_line(aes(year, unemployment_rate_in_percent, group = 1)) + labs(title = paste(&quot;Unemployment in&quot;, .y)))) %&gt;% pull(plots) ``` This is what the output looks like. It is of course possible to write several R chunks: --- title: &quot;My Title&quot; author: &quot;My name&quot; date: today format: html: code-fold: true --- ## This is a simple quarto document ```{r} #| warning: false library(dplyr) library(tidyr) library(purrr) library(ggplot2) library(myPackage) data(&quot;unemp&quot;) unemp &lt;- unemp %&gt;% janitor::clean_names() %&gt;% filter(level == &quot;Commune&quot;) ``` There are `r length(unique(unemp$place_name))` communes in the dataset. Below we plot the unemployment rate for 3 communes: ```{r} unemp %&gt;% filter(place_name %in% c(&quot;Luxembourg&quot;, &quot;Esch-sur-Alzette&quot;, &quot;Wiltz&quot;)) %&gt;% group_by(place_name) %&gt;% nest() %&gt;% mutate(plots = map2(.x = data, .y = place_name, ~ggplot(data = .x) + theme_minimal() + geom_line(aes(year, unemployment_rate_in_percent, group = 1)) + labs(title = paste(&quot;Unemployment in&quot;, .y)))) %&gt;% pull(plots) ``` This is what the output looks like. 8.2.1 Python and Julia code chunks It is possible, inside the same Quarto document, to define code chunks that run Python (or even Julia) code. Put the following lines inside a file called example2.qmd (to run the example below, you will need to have Python installed): --- title: &quot;R and Python&quot; author: &quot;Bruno Rodrigues&quot; date: today --- ## This is a simple quarto document ```{r} #| warning: false library(dplyr) library(tidyr) library(purrr) library(ggplot2) library(myPackage) data(&quot;unemp&quot;) unemp &lt;- unemp %&gt;% janitor::clean_names() %&gt;% filter(level == &quot;Commune&quot;) ``` ```{python} print(&quot;hello from Python&quot;) import sys print(sys.version) ``` This is what the output looks like. If you have trouble rendering this line, make sure that you have the jupyter and jupyterlab modules installed. It is also possible to pass objects from R to Python (and vice-versa): --- title: &quot;R and Python&quot; author: &quot;Bruno Rodrigues&quot; date: today --- ## This is a simple quarto document ```{r} #| warning: false library(dplyr) library(tidyr) library(purrr) library(ggplot2) library(myPackage) data(&quot;unemp&quot;) unemp &lt;- unemp %&gt;% janitor::clean_names() %&gt;% filter(level == &quot;Commune&quot;) ``` The data that was loaded and cleaned from R can be accessed from Python using `r.unemp`: ```{python} import pandas as pd unemp_pd = pd.DataFrame(r.unemp) unemp_pd.head ``` This is what the output looks like. The HTML output is quite flexible, as it is possible to also integrate JS libraries. The following example uses the {g2r} library (an R wrapper around the g2 javascript library) for creating visualisations. To run the following code, make sure that you have the {g2r} package installed (can only be install from github): devtools::install_github(&quot;devOpifex/g2r&quot;) The source file looks like this: --- title: &quot;Quarto and JS libraries&quot; author: &quot;My name&quot; date: today format: html: code-fold: true --- ## This is a simple quarto document showing basic plot interactivity using {g2r} ```{r} #| warning: false library(dplyr) library(tidyr) library(purrr) library(g2r) library(myPackage) data(&quot;unemp&quot;) unemp &lt;- unemp %&gt;% janitor::clean_names() %&gt;% filter(level == &quot;Commune&quot;) ``` There are `r length(unique(unemp$place_name))` communes in the dataset. Below we plot the unemployment rate for 3 communes: ```{r} unemp %&gt;% filter(place_name %in% c(&quot;Luxembourg&quot;, &quot;Esch-sur-Alzette&quot;, &quot;Wiltz&quot;)) %&gt;% g2(data = .) %&gt;% fig_line(asp(year, unemployment_rate_in_percent, color = place_name)) ``` This is what the output looks like. It is possible to use other JS libraries, like here DataTables, wrapped inside the {DT} package: --- title: &quot;Quarto and JS libraries&quot; author: &quot;My name&quot; date: today format: html: toc: true code-fold: true --- ## Basic plot interactivity using {g2r} ```{r} #| warning: false library(dplyr) library(tidyr) library(purrr) library(g2r) library(DT) library(myPackage) data(&quot;unemp&quot;) unemp &lt;- unemp %&gt;% mutate(year = as.character(year)) %&gt;% janitor::clean_names() %&gt;% filter(level == &quot;Commune&quot;) ``` There are `r length(unique(unemp$place_name))` communes in the dataset. Below we plot the unemployment rate for 3 communes: ```{r} unemp %&gt;% filter(place_name %in% c(&quot;Luxembourg&quot;, &quot;Esch-sur-Alzette&quot;, &quot;Wiltz&quot;)) %&gt;% g2(data = .) %&gt;% fig_line(asp(year, unemployment_rate_in_percent, color = place_name)) ``` ## Interactive tables with {DT} ```{r} unemp %&gt;% DT::datatable(filter = &quot;top&quot;) ``` ## Others You can find more widgets over [here](http://gallery.htmlwidgets.org/). This is what the output looks like. The final example illustrates templating. It is possible to write code that generates qmd code: --- title: &quot;Templating with Quarto&quot; author: &quot;Bruno Rodrigues&quot; date: today format: html: toc: true --- # Set up The goal is to have a frequency table for each question in a survey. But we do not want to have to do it by hand, so we define a function to create a table, and then, using the templating capabilities of Quarto, write some code to generate valid qmarkdown code. In the example below our survey only has 4 questions, but the solution described trivially scales to an infinity of questions. This is not the case if you’re solving this problem by hand. Start by loading the data and defining some needed variables: ```{r} #| warning: false library(lubridate) library(dplyr) library(purrr) library(rlang) library(DT) survey_data &lt;- read.csv( &quot;https://gist.githubusercontent.com/b-rodrigues/0c2249dec5a9c9477e0d1ad9964a1340/raw/873bcc7532b8bad613235f029884df1d0b947c90/survey_example.csv&quot; ) ``` Let’s take a look at the data: ```{r} datatable(survey_data) ``` The column names are actually questions, so we save those in a variable: ```{r} questions &lt;- colnames(survey_data) questions ``` Now we define question codes: ```{r} codes &lt;- paste0(&quot;var_&quot;, seq(1, 4)) codes ``` We create a lookup table that links questions to their codes: ```{r} lookup &lt;- bind_cols(&quot;codes&quot; = codes, &quot;questions&quot; = questions) datatable(lookup) ``` Finally, we replace the question names in the dataset by the code: ```{r} colnames(survey_data) &lt;- codes datatable(survey_data) ``` Now, we define a function that creates a frequency table. This function has two arguments: `dataset` and `var`. It uses the `dplyr::count()` function to count each instance of the levels of `var` in `dataset`. Then it uses the `knitr::kable()` function. This functions takes a data frame as an argument and returns a table formatted in markdown code: ```{r} create_table &lt;- function(dataset, var){ dataset %&gt;% count(!!var) %&gt;% knitr::kable() } ``` The next function is the one that does the magic: it takes only one argument as an input, and generates valid markdown code using the `knitr::knit_expand()` function. Any variable between `{{}}` gets replaced by its value (so `{{question}}` gets replaced by the question that gets fetched from the lookup table defined above). Using this function, we can now loop over question codes, and what we get in return is valid markdown code that defines a section with the question as the title, and our table. ```{r} return_section &lt;- function(var){ a &lt;- knitr::knit_expand(text = c(&quot;## {{question}}&quot;, create_table(survey_data, var)), question = lookup$questions[grepl(quo_name(var), lookup$codes)]) cat(a, sep = &quot;\\n&quot;) } ``` Our codes are strings, so to be able to use them inside of `dplyr::count()` we need to define them as bare string, or symbols. This can be done using the `rlang::sym()` function. If this is confusing, try running `count(mtcars, &quot;am&quot;)` and you will see that it will not return what you want (compare to `count(mtcars, am)`). This is also why we needed `rlang::quo_name()` in the function above, to convert the symbol back to a string, which is what `grepl()` requires: ```{r} sym_codes &lt;- map(codes, sym) ``` Finally, we can create the sections. The line below uses `purrr::walk()`, which is equivalent to `purrr::map()`, the difference being that we use `purrr::walk()` when we are interested in the side effects of a function: ```{r, results=&quot;asis&quot;} walk(sym_codes, return_section) ``` This is what the output looks like.. 8.3 Other output formats 8.3.1 Word Let’s now generate a Word document using Quarto. As you will see, this will be quite easy; but keep in mind that the basic interactivity that we have seen with HTML outputs won’t be possible here (but templating will work). Render the following source file to get back a .docx document (you don’t even need to have MS Word installed for it to work), and take of what we changed from the previous file: Output changed from html to docx; No more {DT}, but {pander} instead to generated .docx tables Here is the file: --- title: &quot;Templating with Quarto&quot; author: &quot;Bruno Rodrigues&quot; date: today format: docx --- # Set up The goal is to have a frequency table for each question in a survey. But we do not want to have to do it by hand, so we define a function to create a table, and then, using the templating capabilities of Quarto, write some code to generate valid qmarkdown code. In the example below our survey only has 4 questions, but the solution described trivially scales to an infinity of questions. This is not the case if you’re solving this problem by hand. Start by loading the data and defining some needed variables: ```{r} #| warning: false library(lubridate) library(dplyr) library(purrr) library(pander) library(rlang) survey_data &lt;- read.csv( &quot;https://gist.githubusercontent.com/b-rodrigues/0c2249dec5a9c9477e0d1ad9964a1340/raw/873bcc7532b8bad613235f029884df1d0b947c90/survey_example.csv&quot; ) ``` Let’s take a look at the data: ```{r} pander(head(survey_data)) ``` The column names are actually questions, so we save those in a variable: ```{r} questions &lt;- colnames(survey_data) questions ``` Now we define question codes: ```{r} codes &lt;- paste0(&quot;var_&quot;, seq(1, 4)) codes ``` We create a lookup table that links questions to their codes: ```{r} lookup &lt;- bind_cols(&quot;codes&quot; = codes, &quot;questions&quot; = questions) pander(lookup) ``` Finally, we replace the question names in the dataset by the code: ```{r} colnames(survey_data) &lt;- codes pander(survey_data) ``` Now, we define a function that creates a frequency table. This function has two arguments: `dataset` and `var`. It uses the `dplyr::count()` function to count each instance of the levels of `var` in `dataset`. Then it uses the `knitr::kable()` function. This functions takes a data frame as an argument and returns a table formatted in markdown code: ```{r} create_table &lt;- function(dataset, var){ dataset %&gt;% count(!!var) %&gt;% knitr::kable() } ``` The next function is the one that does the magic: it takes only one argument as an input, and generates valid markdown code using the `knitr::knit_expand()` function. Any variable between `{{}}` gets replaced by its value (so `{{question}}` gets replaced by the question that gets fetched from the lookup table defined above). Using this function, we can now loop over question codes, and what we get in return is valid markdown code that defines a section with the question as the title, and our table. ```{r} return_section &lt;- function(var){ a &lt;- knitr::knit_expand(text = c(&quot;## {{question}}&quot;, create_table(survey_data, var)), question = lookup$questions[grepl(quo_name(var), lookup$codes)]) cat(a, sep = &quot;\\n&quot;) } ``` Our codes are strings, so to be able to use them inside of `dplyr::count()` we need to define them as bare string, or symbols. This can be done using the `rlang::sym()` function. If this is confusing, try running `count(mtcars, &quot;am&quot;)` and you will see that it will not return what you want (compare to `count(mtcars, am)`). This is also why we needed `rlang::quo_name()` in the function above, to convert the symbol back to a string, which is what `grepl()` requires: ```{r} sym_codes &lt;- map(codes, sym) ``` Finally, we can create the sections. The line below uses `purrr::walk()`, which is equivalent to `purrr::map()`, the difference being that we use `purrr::walk()` when we are interested in the side effects of a function: ```{r, results=&quot;asis&quot;} walk(sym_codes, return_section) ``` You can download the output here. Unlike with HTML outputs, it is also not possible to enable code folding, but you could hide the code completely using the “#| echo = false” chunk option. If you wan to hide all the code without having to specify “#| echo = false” on each chunk you can also add the execute option to the document header: --- title: &quot;Templating with Quarto&quot; author: &quot;Bruno Rodrigues&quot; date: today format: docx execute: echo: false --- You can use a document as a template for Word documents generated with Quarto. For this, you must create a new Word file, and update the styles. This document, with the updated styles, can then be referenced in the header to act as a template: --- title: &quot;Using a custom Word style&quot; author: &quot;Bruno Rodrigues&quot; date: today format: docx: reference-doc: fancy_template.docx execute: echo: false --- # Introduction ## MS Word is great (lol) This is normal text that is unreadable. Just put fancy_template.docx in the same folder as your source qmd file. You can download the template I’ve used from here to test things out. For more details, visit this page. 8.3.2 Presentations It is also possible to create presentations using Quarto. There are output formats as well: HTML, PDF and Powerpoint. I will not discuss this here, because it is quite easy to get started, simply follow along. 8.3.3 PDF I do need to discuss the PDF output a little bit. In order to generate PDF files, Quarto uses the pdflatex compiler (or rather pandoc, called by Quarto, uses pdflatex). pdflatex compiles .tex source files to PDF, so what Quarto does (by leveraging pandoc) is first converting a .qmd file to a .tex file, and then call pdflatex to compile it. .tex files are the file extension of the Latex typesetting language, extensively used in science. It makes it easy to write complex mathematical formulas, like this one: \\[\\begin{align*} S(\\omega) &amp;= \\frac{\\alpha g^2}{\\omega^5} e^{[ -0.74\\bigl\\{\\frac{\\omega U_\\omega 19.5}{g}\\bigr\\}^{\\!-4}\\,]} \\\\ &amp;= \\frac{\\alpha g^2}{\\omega^5} \\exp\\Bigl[ -0.74\\Bigl\\{\\frac{\\omega U_\\omega 19.5}{g}\\Bigr\\}^{\\!-4}\\,\\Bigr] \\end{align*}\\] Latex is a bit unwieldly, so using Markdown to write scientific documents is becoming more and more popular. However, Latex still has an edge when it comes to tables. But thankfully, it is possible to simply embed the Latex code that produces these tables in Markdown, and there are packages that export regression table directly to PDF. In any case, in order to compile to PDF, you need to install Texlive. Installing Texlive is frankly a mess, but thankfully there is a very simple alternative called TinyTex. TinyTex is both available as an R package or as a standalone installation, and was put together by the author of RMarkdown (in a sense, Quarto is a spiritual successor to RMarkdown). This package installs a self-contained Texlive installation locally, which can then be used to compile PDF documents (from, or outside of R/RStudio). I highly recommend you use Tinytex. Instructions can be found here. Once you’ve installed TinyTex, you can try to compile the following example document (the first time you run this, it might take some time, as the required packages get installed): --- title: &quot;PDF example with table&quot; format: pdf --- ## A PDF document using Quarto In the code below, we fit several models and then use the `{modelsummary}` package to print a nicely formatted table with minimal effort: ```{r} library(modelsummary) url &lt;- &#39;https://vincentarelbundock.github.io/Rdatasets/csv/HistData/Guerry.csv&#39; dat &lt;- read.csv(url) models &lt;- list( &quot;OLS 1&quot; = lm(Donations ~ Literacy + Clergy, data = dat), &quot;Poisson 1&quot; = glm(Donations ~ Literacy + Commerce, family = poisson, data = dat), &quot;OLS 2&quot; = lm(Crime_pers ~ Literacy + Clergy, data = dat), &quot;Poisson 2&quot; = glm(Crime_pers ~ Literacy + Commerce, family = poisson, data = dat), &quot;OLS 3&quot; = lm(Crime_prop ~ Literacy + Clergy, data = dat) ) modelsummary(models) ``` And an equation, for good measure: \\begin{align*} S(\\omega) &amp;= \\frac{\\alpha g^2}{\\omega^5} e^{[ -0.74\\bigl\\{\\frac{\\omega U_\\omega 19.5}{g}\\bigr\\}^{\\!-4}\\,]} \\\\ &amp;= \\frac{\\alpha g^2}{\\omega^5} \\exp\\Bigl[ -0.74\\Bigl\\{\\frac{\\omega U_\\omega 19.5}{g}\\Bigr\\}^{\\!-4}\\,\\Bigr] \\end{align*} This is what the output looks like (scroll down to page 2).. It is possible to author, many, many, different types of documents using Quarto. For more formats, consult this page. Quarto is still very new – it was officially anounced in July of 2022 by Posit– so much more content will arrive. There are still many features of Quarto that we have not explored, so take your time to read its documentation in detail. 8.4 Interactive web applications with {shiny} {shiny} is a package developed by Posit to build interactive web applications. These apps can be quite “simple” (for example, an app that shows a graph but in which the user can choose the variable to plot), but can be arbitrarily complex. Some people even go as far as make games with {shiny}. A version for Python is also in alpha, and you can already experiment with it. In this section, I will give a very, very short introduction to {shiny}. This is because {shiny} is so feature-rich, that I could spend 20 hours teaching you and even then we would not have seen everything. That being said, we can with only some cursory knowledge build some useful apps. These apps can run locally on your machine, but they’re really only useful if deploy them on a server, so that users can then use these web apps on their browsers. 8.4.1 The basic structure of a Shiny app Shiny apps are always made of at least 2 parts: a server and a ui. In general, each of these parts are in separate scripts called server.R and ui.R. It is possible to have another script, called global.R, where you can define variables that you want to be available for both the server and the ui, and to every user of your app. Let’s start by building a very basic app. This app will allow users to visualize unemployment data for Luxembourg. For now, let’s say that we want users only to be able to select communes, but not variables. The example code below is based on this official example (this is how I recommend you learn by the way. Take a look at the different example there are and adapt them to suit your needs! You can find the examples here). Create a folder called something like my_app and then create three scripts in it: global.R server.R ui.R Let’s start with global.R: library(myPackage) library(dplyr) library(ggplot2) data(&quot;unemp&quot;) In the global.R file, we load the required packages and data. This is now available everywhere. Let’s continue with the server.R script: server &lt;- function(session, input, output) { filtered_data &lt;- reactive( unemp %&gt;% filter(place_name %in% input$place_name_selected) ) output$unemp_plot &lt;- renderPlot({ ggplot(data = filtered_data()) + theme_minimal() + geom_line(aes(year, unemployment_rate_in_percent, color = place_name)) + labs(title = paste(&quot;Unemployment in&quot;, paste(input$place_name_selected, collapse = &quot;, &quot;))) }) } Several things need to be commented here: first, the script contains a single function, called server(). This function take three arguments, session, input and output. I won’t go into details here, but you should know that you will never call the server() function yourself, and that these arguments are required so the function can… function. I will leave a reference at the end of this section with more details. The next important thing is that we defined an object called filtered_data. This is a reactive object. What this means is that this object should get recomputed every time the user interacts with it. But how does the user interact with it? By choosing the place_name he or she wants to see! The predicate inside filter() is place_name %in% input$place_name_selected. Where does that input$place_name_selected come from? This comes from the ui (that we have not written yet). But the idea is that the user will be able to chose place names from a list, and this list will be called place_name_selected and will contain the place names that the user wants to see. Finally, we define a new object called output$unemp_plot. The goal of the server() function is to compute things that will be part of the output list. This list, and the objects it contains, get then rendered in the ui. unemp_plot is a ggplot graph that uses the reactive data set we defined first. Notice the () after filtered_data inside the ggplot call. These are required; this is how we say that the reactive object must be recomputed. If the plot does not get rendered, the reactive data set does not get computed, since it never gets called. Ok so now to the ui. Let’s take inspiration from the same example again: ui &lt;- function(request){ fluidPage( titlePanel(&quot;Unemployment in Luxembourg&quot;), sidebarLayout( sidebarPanel( selectizeInput(&quot;place_name_selected&quot;, &quot;Select place:&quot;, choices=unique(unemp$place_name), multiple = TRUE, selected = c(&quot;Rumelange&quot;, &quot;Dudelange&quot;), options = list( plugins = list(&quot;remove_button&quot;), create = TRUE, persist = FALSE # keep created choices in dropdown ) ), hr(), helpText(&quot;Original data from STATEC&quot;) ), mainPanel( plotOutput(&quot;unemp_plot&quot;) ) ) ) } I’ve added some useful things to the ui. First of all, I made it a function of an argument, request. This is useful for bookmarking the state of the variable. We’ll add a bookmark button later. The ui is divided into two parts, a sidebar panel, and a main panel. The sidebar panel is where you will typically add dropdown menus, checkboxes, radio buttons, etc, for the users to make various selections. In the main panel, you will show the result of their selections. In the sidebar panel I add a selectizeInput() to create a dynamic dropdown list using the selectize JS library, included with {shiny}. The available choices are all the unique place names contained in our data, I allow users to select multiple place names, by default two communes are selected and using the options argument I need little “remove” buttons in the selected commune names. Finally, in the main panel I use the plotOutput() function to render the plot. Notice that I use the name of the plot defined in the server, “unemp_plot”. Finally, to run this, add a new script, called app.R and add the following line in it: shiny::runApp(&quot;.&quot;) You can now run this script in RStudio, or from any R console, and this should open a web browser with your app. Believe it or not, but this app contains almost every ingredient you need to know to build shiny apps. But of course, there are many, many other widgets that you can use to give your users even more ways to interact with applications. I will give you another example, and then we will need to move on. 8.4.2 Slightly more advanced shiny users can choose which variable they want to see users can choose position of legend switching from line plot to polygon plot action button to plot bookmark button replace ggplot with g2r 8.4.3 References The server function 8.5 How to build data products using {targets} "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
