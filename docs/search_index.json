[["index.html", "Reproducible Analytical Pipelines - Master’s of Data Science Chapter 1 Introduction 1.1 Schedule 1.2 Reproducible analytical pipelines? 1.3 Data products? 1.4 Why R? Why not [insert your favourite programming language] 1.5 Pre-requisites", " Reproducible Analytical Pipelines - Master’s of Data Science Bruno Rodrigues 2022-10-08 Chapter 1 Introduction 1.1 Schedule 2022/10/25, morning: Introduction to the course and first steps with R 2022/10/25, afternoon: Explore and visualize data with R 2022/10/31, afternoon: Functional programming 2022/11/07, afternoon: Git and package development 2022/11/08, morning: Machine learning with {tidymodels} 2022/11/08, afternoon: Literate programming and {shiny} 2022/11/21, afternoon: Build automation with {targets} 2022/11/22, noon: Putting it all together with Docker 1.2 Reproducible analytical pipelines? This course is my take on setting up code that results in some data product. This code has to be reproducible, documented and production ready. Many resources on the subject exist, such as (Gregory and Upson 2022). The basic idea of RAPs is to have code that always produces the same result when run, whatever this result might be. This is obviously crucial in research and science, but this is also the case in businesses that deal with data science/data-driven decision making etc. A well documented RAP avoids a lot of headache and is usually re-usable for other projects as well. 1.3 Data products? In this course each of you will develop a data product. A data product is anything that requires data as an input. This can be a very simple report in PDF or Word format to a complex webapp. This website is actually also a data product. In this course we will not focus too much on how to create automated reports or webapps (but I’ll give an introduction to these, don’t worry) but our focus will be on the set up of a pipeline that results in these data products in a reproducible way. 1.4 Why R? Why not [insert your favourite programming language] In my absolutely objective opinion R is currently the most interesting and simple language you can use to create such data products. If you learn R you have access to almost 19000 packages (as of October 2022) to: clean data (see: {dplyr}, {tidyr}, {data.table}…); work with medium and big data (see: {arrow}, {sparklyr}…); visualize data (see: {ggplot2}, {plotly}, {echarts4r}…); do literate programming (using Rmarkdown, you can write books, documents even create a website); do functional programming (see: {purrr}…); call other languages for R (see: {reticulate} to call Python from R); do machine learning and AI (see: {tidymodels}, {tensorflow}, {keras}…) create webapps (see: {shiny}…) domain specific statistics/machine learning (see CRAN Task Views for an exhaustive list); and more It’s not just about what the packages provide: installing R and its packages and dependencies is rarely frustrating, which is not the case with Python (Python 2 vs Python 3, pip vs conda, pyenv vs venv…, dependency hell is a real place full of snakes) Does that mean R is perfect? No, but it sucks less than alternatives. 1.5 Pre-requisites I will assume basic programming knowledge, and not much more. If you need to set up R on your computer you can read the intro to my other book Modern R with the tidyverse The course will be very, very hands-on. I’ll give general hints and steps, and ask you to do stuff. It will not always be 100% simple and obvious, and you will need to also think a bit by yourself. I’ll help of course, so don’t worry. The idea is to put you in the shoes of a read data scientist that gets asked at 09:00 in the morning to come up with a solution to a problem by COB. In 99% of the cases, you will never have encountered that problem ever, as it will be very specific to the company you’re working at. Google and Stackoverflow will be your only friends in these moments. "],["introduction-to-r.html", "Chapter 2 Introduction to R 2.1 Reading in data with R 2.2 A little aside on pipes 2.3 Exploring and cleaning data with R 2.4 Data visualization", " Chapter 2 Introduction to R What you’ll have learned by the end of the chapter: reading and writing, exploring (and optionally visualising) data. 2.1 Reading in data with R Your first job is to actually get the following datasets into an R session. First install the {rio} package, then download the following datasets: mtcars.csv mtcars.dta mtcars.sas7bdat multi.xlsx Also download the following 4 csv files and put them in a directory called unemployment: unemp_2013.csv unemp_2014.csv unemp_2015.csv unemp_2016.csv Finally, download this one as well, but put it in a folder called problem: mtcars.csv and take a look at chapter 3 of my other book, Modern R with the {tidyverse} and follow along. This will teach you to import and export data. To know which packages are used by {rio}, you can take a look at this vignette. If you need to import very large datasets (potentially several GBs), you might want to look at packages like {vroom} (see the benchmark were a 1.5G csv file gets read in seconds by {vroom} here. For even larger files, take a look at {arrow} here. This package is able to efficiently read very large files (csv, json, parquet and feather formats) 2.2 A little aside on pipes Since R version 4.1, a forward pipe |&gt; is included. It allows to do this: 4 |&gt; sqrt() ## [1] 2 Before R version 4.1, there was already a forward pipe, introduced with the {magrittr} package (and automatically loaded by many other packages): library(dplyr) 4 %&gt;% sqrt() ## [1] 2 Both expressions above are equivalent to sqrt(4). You will see why this is useful very soon. For now, just know this. 2.3 Exploring and cleaning data with R Take a look at chapter 4 of my other book, ideally you should study the entirety of the chapter, but for our purposes you should really focus on sections 4.3, 4.4, 4.5.3, 4.5.4, 4.7 and 4.8. 2.4 Data visualization We’re not going to focus on visualization due to lack of time. If you need to create graphs, read chapter 5. "],["a-primer-on-functional-programming.html", "Chapter 3 A primer on functional programming 3.1 Introduction", " Chapter 3 A primer on functional programming What you’ll have learned by the end of the chapter: writing your own functions, functional programming basics (map, reduce, anonymous functions). 3.1 Introduction Functional programming is a way of write programs that relies exclusively on functions. Mathematical functions have a very property: for any given input, they ALWAYS return exactly the same output. This is what we want to achieve with the functions that we will write. Functions that always return the same result are called pure, and a language that only allows writing pure functions is called a pure functional programming language. R is not a pure functional programming language, so we have to be careful not to write unpure function that manipulate the global state. But what is state? Run the following code in your console: ls() This will list every object defined in your state. Now run the following line: x &lt;- 1 and then ls(). x should now be listed alongside the other objects. You just manipulated the state of your current R session. Now if you run something like: x + 1 This will produce 2. We want to avoid pipelines that depend on some definition of some variable somewhere, which could be subject to change, because this could mean that 2 different runs of the same pipeline could produce 2 different results. Notice that I used the verb avoid in the sentence before. This is sometimes not possible to avoid. Such situations have to be carefully document and controlled. A very practical consequence of using functional programming is that loops are not used, because loops are imperative and imperative programming is all about manipulating state. However, there are situations where loops are more efficient than the alternative (in R at least). So we will still learn and use them, but only when absolutely necessary. Another consequence is that our code will live in plain text files, and not in Jupyter (or equivalent) notebooks. Not only does imperative code have state, but notebooks themselves have state. You should avoid notebooks at all costs, even for experimenting. Let’s first learn about actually writing functions. Read chapter 7 of my other book. The most important concepts for this course are discussed in the following sections: functions that take functions as arguments (section 7.4) functions that take data (and the data’s columns) as arguments (section 7.6); Once again, you should ideally work through the whole chapter, and then tackle chapter 8. What’s important there are: purrr::map(), purrr::reduce() (sections 8.3.1 and 8.3.2) And list based workflows (section 8.4) "],["git.html", "Chapter 4 Git 4.1 Installing Git 4.2 Basic Git commands", " Chapter 4 Git 4.1 Installing Git 4.2 Basic Git commands "],["a-package-for-a-project.html", "Chapter 5 A package for a project 5.1 Getting started 5.2 Adding functions 5.3 Documentation 5.4 Testing your package", " Chapter 5 A package for a project 5.1 Getting started 5.2 Adding functions 5.2.1 Functions dependencies 5.3 Documentation 5.3.1 Documenting functions 5.3.2 Documenting the package 5.4 Testing your package "],["unit-tests.html", "Chapter 6 Unit tests 6.1 Introduction 6.2 Unit testing with {testthat}", " Chapter 6 Unit tests 6.1 Introduction 6.2 Unit testing with {testthat} "],["setting-up-an-actual-pipeline-with-targets.html", "Chapter 7 Setting up an actual pipeline with {targets} 7.1 A first toy example 7.2 Using your package in a {targets} pipeline", " Chapter 7 Setting up an actual pipeline with {targets} 7.1 A first toy example 7.2 Using your package in a {targets} pipeline "],["rmarkdown.html", "Chapter 8 Rmarkdown 8.1 HTML output 8.2 Word and PPTX outputs 8.3 Flexdashboard (no shiny)", " Chapter 8 Rmarkdown 8.1 HTML output slides as well 8.2 Word and PPTX outputs 8.3 Flexdashboard (no shiny) "],["going-beyond-static-outputs-with-shiny.html", "Chapter 9 Going beyond static outputs with Shiny", " Chapter 9 Going beyond static outputs with Shiny "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
