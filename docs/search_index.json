[["unit-tests.html", "Chapter 6 Unit tests 6.1 Introduction 6.2 Testing your package 6.3 Back to developing again 6.4 And back to testing", " Chapter 6 Unit tests What you’ll have learned by the end of the chapter: what unit tests are, how to write them, and how to test your package thoroughly. 6.1 Introduction It might not have seemed like it, but developing our own package was actually the first step in writing reproducible code. Packaged code is easy to share, and much easier to run than code that lives inside scripts. When you share code, be it with future you or others, you have a responsibility to ship high quality code. Unit tests are one way to ensure that your code works as intented, but it is not a panacea. But if you write short, well-documented functions, and you package them, and test them thoroughly, you are on the right track for success. But what are unit tests? Unit tests are pieces of code that test other pieces of code (called units in this context). It turns out that functions are units of code, and that makes testing them quite easy. I hope that you are starting to see the pieces coming all together: I introduced you to functional programming and insisted that you write your code as a sequence of functions calls, because it makes it easier to package and document everything. And now that your code lives inside a package, as a series of functions, it will be very easy to test these functions (or units of code). 6.2 Testing your package To make sure that each one of us starts with the exact same package and code, you will first of all fork the following repository that you can find here. Forking the repository will add a copy of the repository to your github account. You can now clone your fork of the repo (make sure you clone using the ssh link!) and start working! Because our code is packaged, starting to write unit tests will be very easy. For this, open RStudio and make sure your package’s project is opened: In order to set up the required files and folders for unit testing, run the following line in the R console: usethis::use_test(&quot;clean_unemp&quot;) You should see a folder called tests appear inside the package. Inside tests, there is another folder called testthat, and inside this folder you should find a file called test-clean_unemp.R. This file should contain an example: test_that(&quot;multiplication works&quot;, { expect_equal(2 * 2, 4) }) This is quite self-explanatory; test_that() is the function that we are going to use to write tests. It takes a string as an argument, and a test. For the string write an explanatory name. This will make it easier to find the test if it fails. expect_equal() is a function that tests the equality between its arguments. On one side we have 2 * 2, and on the other, 4. All our tests will look somewhat like this. There are many expect_ functions, that allow you to test for many conditions. You can take a look at {testthat}’s function reference for a complete list. So, what should we test? Well, here are several ideas: Is the function returning an expected value for a given input? Can the function deal with all kinds of input? What happens if an unexpected input is provided? Is the function failing as expected for certain inputs? Is the function dealing with corner cases as intended? Let’s try to write some tests for our clean_unemp() function now, and start to consider each of these questions. 6.2.1 Is the function returning an expected value for a given input? Let’s start by testing if our function actually returns data for the Grand-Duchy of Luxembourg if the user provides a correct regular expression. Add these lines to the script (and remove the example test while you’re at it): unemp_2013 &lt;- readr::read_csv(&quot;https://raw.githubusercontent.com/b-rodrigues/modern_R/master/datasets/unemployment/unemp_2013.csv&quot;) test_that(&quot;selecting the grand duchy works&quot;, { returned_value &lt;- clean_unemp( unemp_2013, grepl(&quot;Grand-D.*&quot;, commune), active_population) expected_value &lt;- tibble::as_tibble( list(&quot;year&quot; = 2013, &quot;commune&quot; = &quot;Grand-Duche de Luxembourg&quot;, &quot;active_population&quot; = 242694)) expect_equal(returned_value, expected_value) }) So what’s going on here? First, I need to get the data. I load the data outside of the test, so it’ll be available to every test afterwards as well. Then, inside the test, I need to define two more variables: the actual value returned by the function, and the value that we expect. I need to create this value by hand, and I do so using the tibble::as_tibble() function. This function takes a list as an argument and converts it to a tibble. I did not explain what tibbles are yet: tibbles are basically the same as a data frame, but have a nicer print method, and other niceties. In practice, you don’t need to think about tibbles too much, but here you need to be careful: clean_unemp() returns a tibble, because that’s what {dplyr} functions return by default. So if in your test you compare a tibble to a data.frame, your test will fail, because their classes are not equal. So I need to define my expected value as a tibble for the test to pass. You can now save the script, and press CTRL-SHIFT-T to run the test. The test should pass, if not, there’s either something wrong with your function, with the inputs you provided to it, or with the expected value. You can keep adding tests to this script, to cover every possible use case: test_that(&quot;selecting cantons works&quot;, { returned_value &lt;- clean_unemp( unemp_2013, grepl(&quot;Canton&quot;, commune), active_population) expected_value &lt;- readr::read_csv(&quot;test_data_cantons.csv&quot;) expect_equal(returned_value, expected_value) }) In the test above, I cannot write the expected value by hand. So what I did instead was run my function in a terminal, and save the output in a csv file. I used the following code for this: clean_unemp(unemp_2013, grepl(&quot;Canton&quot;, commune), active_population) %&gt;% readr::write_csv(&quot;tests/testthat/test_data_cantons.csv&quot;) I inspected this output to make sure everything was correct. I can now keep this csv file and test my function against it. Should my function fail when tested against it, I know that something is wrong. We can do the same for communes. First, save the “ground truth” in a csv file: clean_unemp(unemp_2013, !grepl(&quot;(Canton|Grand-D.*)&quot;, commune), active_population) %&gt;% readr::write_csv(&quot;tests/testthat/test_data_communes.csv&quot;) Then, we can use this csv file in our tests: test_that(&quot;selecting communes works&quot;, { returned_value &lt;- clean_unemp( unemp_2013, !grepl(&quot;(Canton|Grand-D.*)&quot;, commune), active_population) expected_value &lt;- readr::read_csv(&quot;test_data_communes.csv&quot;) expect_equal(returned_value, expected_value) }) We could even add a test for a specific commune: test_that(&quot;selecting one commune works&quot;, { returned_value &lt;- clean_unemp( unemp_2013, grepl(&quot;Kayl&quot;, commune), active_population) expected_value &lt;- tibble::as_tibble( list(&quot;year&quot; = 2013, &quot;commune&quot; = &quot;Kayl&quot;, &quot;active_population&quot; = 3863)) expect_equal(returned_value, expected_value) }) So your final script would look something like this: unemp_2013 &lt;- readr::read_csv(&quot;https://raw.githubusercontent.com/b-rodrigues/modern_R/master/datasets/unemployment/unemp_2013.csv&quot;, show_col_types = FALSE) test_that(&quot;selecting the grand duchy works&quot;, { returned_value &lt;- clean_unemp( unemp_2013, grepl(&quot;Grand-D.*&quot;, commune), active_population) expected_value &lt;- tibble::as_tibble( list(&quot;year&quot; = 2013, &quot;commune&quot; = &quot;Grand-Duche de Luxembourg&quot;, &quot;active_population&quot; = 242694)) expect_equal(returned_value, expected_value) }) test_that(&quot;selecting cantons work&quot;, { returned_value &lt;- clean_unemp( unemp_2013, grepl(&quot;Canton&quot;, commune), active_population) expected_value &lt;- readr::read_csv(&quot;test_data_cantons.csv&quot;, show_col_types = FALSE) expect_equal(returned_value, expected_value) }) test_that(&quot;selecting communes works&quot;, { returned_value &lt;- clean_unemp( unemp_2013, !grepl(&quot;(Canton|Grand-D.*)&quot;, commune), active_population) expected_value &lt;- readr::read_csv(&quot;test_data_communes.csv&quot;, show_col_types = FALSE) expect_equal(returned_value, expected_value) }) test_that(&quot;selecting one commune works&quot;, { returned_value &lt;- clean_unemp( unemp_2013, grepl(&quot;Kayl&quot;, commune), active_population) expected_value &lt;- tibble::as_tibble( list(&quot;year&quot; = 2013, &quot;commune&quot; = &quot;Kayl&quot;, &quot;active_population&quot; = 3863)) expect_equal(returned_value, expected_value) }) 6.2.2 Can the function deal with all kinds of input? What should happen if your function gets an unexpected input? Let’s write a unit test and then see if it passes. For example, what if the user enters a commune name that is not in Luxembourg? We expect the data frame to be empty, so let’s write a test for that test_that(&quot;wrong commune name&quot;, { returned_value &lt;- clean_unemp( unemp_2013, grepl(&quot;Paris&quot;, commune), active_population) expected_value &lt;- tibble::as_tibble( list(&quot;year&quot; = numeric(0), &quot;commune&quot; = character(0), &quot;active_population&quot; = numeric(0))) expect_equal(returned_value, expected_value) }) This test reveals something interesting: your function returns an empty data frame, but the user might not understand what’s wrong. Maybe we could add a message to inform the user? We could write something like: clean_unemp &lt;- function(unemp_data, level, col_of_interest){ result &lt;- unemp_data |&gt; janitor::clean_names() |&gt; dplyr::filter({{level}}) |&gt; dplyr::select(year, commune, {{col_of_interest}}) if(nrow(result) == 0) { warning(&quot;The returned data frame is empty. This is likely because the `level` argument supplied does not match any rows in the original data.&quot;) } result } Replace the clean_unemp() function from your package with this one, and rerun the tests. The test should still pass, but a warning will be shown. We can test for this as well; is the warning thrown? Let’s write the required test for it: test_that(&quot;wrong commune name: warning is thrown&quot;, { expect_warning({ clean_unemp( unemp_2013, grepl(&quot;Paris&quot;, commune), active_population) }, &quot;This is likely&quot;) }) expect_warning() needs the expression that should raise the warning, and a regular expression. I’ve used the string “This is likely”, which appears in the warning. This is to make sure that the correct warning is raised. Should another warning be thrown, the test will fail, and I’ll know that something’s wrong (try to change the regular expression and rerun the test, you see that it’ll fail). 6.3 Back to developing again Now might be a good time to stop writing tests and think a little bit. While writing these tests, and filling the shoes of your users, you might have realized that your function might not be that great. We are asking users to enter a regular expression to filter data, which is really not great nor user-friendly. And this is because the data we’re dealing with is actually not clean, because the same column mixes three different regional levels. For example, what if the users wants to take a look at the commune “Luxembourg”? clean_unemp( unemp_2013, grepl(&quot;Luxembourg&quot;, commune), active_population) # A tibble: 3 × 3 year commune active_population &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; 2013 Grand-Duche de Luxembourg 242694 2013 Canton Luxembourg 68368 2013 Luxembourg 43368 So the user gets back three rows; that’s because there’s the country, the canton and the commune of Luxembourg. Of course the user can now filter again to just get the commune. But this is not a good interface. What we should do instead is clean the input data. And while we’re at it, we could also provide the data directly inside the package. This way users get the data “for free” once they install the package. Let’s do exactly that. To package data, we first need to create the data-raw folder. This can be done with the following call: usethis::use_data_raw() There’s a script called DATASET.R inside the data-raw folder. This is the script that we should edit to clean the data. Let’s write the following lines in it: ## code to prepare `DATASET` dataset goes here unemp_2013 &lt;- readr::read_csv(&quot;https://raw.githubusercontent.com/b-rodrigues/modern_R/master/datasets/unemployment/unemp_2013.csv&quot;) unemp_2014 &lt;- readr::read_csv(&quot;https://raw.githubusercontent.com/b-rodrigues/modern_R/master/datasets/unemployment/unemp_2014.csv&quot;) unemp_2015 &lt;- readr::read_csv(&quot;https://raw.githubusercontent.com/b-rodrigues/modern_R/master/datasets/unemployment/unemp_2015.csv&quot;) library(dplyr) clean_data &lt;- function(x){ x %&gt;% janitor::clean_names() %&gt;% mutate(level = case_when( grepl(&quot;Grand-D.*&quot;, commune) ~ &quot;Country&quot;, grepl(&quot;Canton&quot;, commune) ~ &quot;Canton&quot;, !grepl(&quot;(Canton|Grand-D.*)&quot;, commune) ~ &quot;Commune&quot; ), commune = ifelse(grepl(&quot;Canton&quot;, commune), stringr::str_remove_all(commune, &quot;Canton &quot;), commune), commune = ifelse(grepl(&quot;Grand-D.*&quot;, commune), stringr::str_remove_all(commune, &quot;Grand-Duche de &quot;), commune), ) %&gt;% select(year, place_name = commune, level, everything()) } my_datasets &lt;- list( unemp_2013, unemp_2014, unemp_2015 ) unemp &lt;- purrr::map_dfr(my_datasets, clean_data) usethis::use_data(unemp, overwrite = TRUE) Running this code creates a dataset called unemp, which users of your package will be able to load using data(\"unemp\") (after having loaded your package). The now contains a new column called level which will make filtering much easier. After usethis::use_data() is done, we can read following message in the R console: ✔ Saving &#39;unemp&#39; to &#39;data/unemp.rda&#39; • Document your data (see &#39;https://r-pkgs.org/data.html&#39;) We are invited to document our data. To do so, create and edit a file called data.R in the R directory: #&#39; Unemployement in Luxembourg data #&#39; #&#39; A tidy dataset of unemployment data in Luxembourg. #&#39; #&#39; @format ## `who` #&#39; A data frame with 7,240 rows and 60 columns: #&#39; \\describe{ #&#39; \\item{year}{Year} #&#39; \\item{place_name}{Name of commune, canton or country} #&#39; \\item{level}{Country, Canton, or Commune} #&#39; \\item{total_employed_population}{Total employed population living in `place_name`} #&#39; \\item{of_which_wage_earners}{... of which are wage earners living in `place_name`} #&#39; \\item{of_which_non_wage_earners}{... of which are non-wage earners living in `place_name`} #&#39; \\item{unemployed}{Total unemployed population living in `place_name`} #&#39; \\item{active_population}{Total active population living in `place_name`} #&#39; \\item{unemployement_rate_in_percent}{Unemployement rate in `place_name`} #&#39; ... #&#39; } #&#39; @source &lt;https://is.gd/e6wKRk&gt; &quot;unemp&quot; You can now rebuild the document using CTRL-SHIFT-D and reload the package using CRTL-SHIFT-L. You should now be able to load the data into your session using data(\"unemp\"). We can now change our function to accommodate this new data format. Let’s edit our function like this: #&#39; Easily filter unemployment data for Luxembourg #&#39; @param unemp_data A data frame containing unemployment data for Luxembourg. #&#39; @param year_of_interest Optional: The year that should be kept. Leave empty to select every year. #&#39; @param place_name_of_interest Optional: The name of the place of interest: leave empty to select every place in `level_of_interest`. #&#39; @param level_of_interest Optional: The level of interest: one of `Country`, `Canton`, `Commune`. Leave empty to select every level with the same place name. #&#39; @param col_of_interest A column of the `unemp` data frame that you wish to select. #&#39; @importFrom janitor clean_names #&#39; @importFrom dplyr filter select #&#39; @importFrom rlang quo `!!` #&#39; @return A data frame #&#39; @export #&#39; @details #&#39; Users can filter data on two variables: the name of the place of interest, and the level of interest. #&#39; By leaving the argument `place_name_of_interest` empty #&#39; @examples #&#39; # Filter on cantons #&#39; clean_unemp(unemp, #&#39; level_of_interest = &quot;Canton&quot;, #&#39; col_of_interest = active_population) #&#39; # Filter on a specific commune #&#39; clean_unemp(unemp, #&#39; place_name_of_interest = &quot;Luxembourg&quot;, #&#39; level_of_interest = &quot;Commune&quot;, #&#39; col_of_interest = active_population) #&#39; # Filter on every level called Luxembourg #&#39; clean_unemp(unemp, #&#39; place_name_of_interest = &quot;Luxembourg&quot;, #&#39; col_of_interest = active_population) clean_unemp &lt;- function(unemp_data, year_of_interest = NULL, place_name_of_interest = NULL, level_of_interest = NULL, col_of_interest){ if(is.null(year_of_interest)){ year_of_interest &lt;- quo(year) } if(is.null(place_name_of_interest)){ place_name_of_interest &lt;- quo(place_name) } if(is.null(level_of_interest)){ level_of_interest &lt;- quo(level) } result &lt;- unemp_data |&gt; janitor::clean_names() |&gt; dplyr::filter(year %in% !!year_of_interest, place_name %in% !!place_name_of_interest, level %in% !!level_of_interest) |&gt; dplyr::select(year, place_name, level, {{col_of_interest}}) if(nrow(result) == 0) { warning(&quot;The returned data frame is empty. This is likely because the `place_name_of_interest` or `level_of_interest` argument supplied does not match any rows in the original data.&quot;) } result } There’s a lot more going on now: if you don’t get everything that’s going on in this function, don’t worry, it is not that important for what follows. But do try to understand what’s happening, especially the part about the optional arguments. 6.4 And back to testing Running our tests now will obviously fail: ➤ devtools::test(&#39;.&#39;) ℹ Testing myPackage ✔ | F W S OK | Context ✖ | 6 0 | clean_unemp [0.3s] ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── Error (test-clean_unemp.R:5:3): selecting the grand duchy works Error in `is.factor(x)`: object &#39;commune&#39; not found Backtrace: 1. myPackage::clean_unemp(...) at test-clean_unemp.R:5:2 2. base::grepl(&quot;Grand-D.*&quot;, commune) at myPackage/R/functions.R:29:2 3. base::is.factor(x) Error (test-clean_unemp.R:21:3): selecting cantons work Error in `is.factor(x)`: object &#39;commune&#39; not found Backtrace: 1. myPackage::clean_unemp(...) at test-clean_unemp.R:21:2 2. base::grepl(&quot;Canton&quot;, commune) at myPackage/R/functions.R:29:2 3. base::is.factor(x) Error (test-clean_unemp.R:34:3): selecting communes works Error in `is.factor(x)`: object &#39;commune&#39; not found Backtrace: 1. myPackage::clean_unemp(...) at test-clean_unemp.R:34:2 2. base::grepl(&quot;(Canton|Grand-D.*)&quot;, commune) at myPackage/R/functions.R:29:2 3. base::is.factor(x) Error (test-clean_unemp.R:47:3): selecting one commune works Error in `is.factor(x)`: object &#39;commune&#39; not found Backtrace: 1. myPackage::clean_unemp(unemp_2013, grepl(&quot;Kayl&quot;, commune), active_population) at test-clean_unemp.R:47:2 2. base::grepl(&quot;Kayl&quot;, commune) at myPackage/R/functions.R:29:2 3. base::is.factor(x) Error (test-clean_unemp.R:63:3): wrong commune name Error in `is.factor(x)`: object &#39;commune&#39; not found Backtrace: 1. myPackage::clean_unemp(unemp_2013, grepl(&quot;Paris&quot;, commune), active_population) at test-clean_unemp.R:63:2 2. base::grepl(&quot;Paris&quot;, commune) at myPackage/R/functions.R:29:2 3. base::is.factor(x) Error (test-clean_unemp.R:80:3): wrong commune name: warning is thrown Error in `is.factor(x)`: object &#39;commune&#39; not found Backtrace: 1. testthat::expect_warning(...) at test-clean_unemp.R:80:2 8. base::grepl(&quot;Paris&quot;, commune) at myPackage/R/functions.R:29:2 9. base::is.factor(x) ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────── ══ Results ═══════════════════════════════════════════════════════════════════════════════════════════════════════════════════ Duration: 0.4 s [ FAIL 6 | WARN 0 | SKIP 0 | PASS 0 ] Warning message: ── Conflicts ────────────────────────────────────────────────────────────────────────────────────────── myPackage conflicts ── ✖ `clean_unemp` masks `myPackage::clean_unemp()`. ℹ Did you accidentally source a file rather than using `load_all()`? Run `rm(list = c(&quot;clean_unemp&quot;))` to remove the conflicts. &gt; At this stage, it might be a good idea to at least commit. Maybe let’s not push yet, and only push once the tests have been rewritten to pass. Commit from RStudio or from a terminal, the choice is yours. We now have to rewrite the tests, to make them pass again. We also need to recreate the csv files for some of the tests, and will probably need to create others. This is what the script containing the tests could look like once you’re done: test_that(&quot;selecting the grand duchy works&quot;, { returned_value &lt;- clean_unemp( unemp, year_of_interest = 2013, level_of_interest = &quot;Country&quot;, col_of_interest = active_population) |&gt; as.data.frame() expected_value &lt;- as.data.frame( list(&quot;year&quot; = 2013, &quot;place_name&quot; = &quot;Luxembourg&quot;, &quot;level&quot; = &quot;Country&quot;, &quot;active_population&quot; = 242694) ) expect_equal(returned_value, expected_value) }) test_that(&quot;selecting cantons work&quot;, { returned_value &lt;- clean_unemp( unemp, year_of_interest = 2013, level_of_interest = &quot;Canton&quot;, col_of_interest = active_population) |&gt; as.data.frame() expected_value &lt;- read.csv(&quot;test_data_cantons.csv&quot;) expect_equal(returned_value, expected_value) }) test_that(&quot;selecting communes works&quot;, { returned_value &lt;- clean_unemp( unemp, year_of_interest = 2013, level_of_interest = &quot;Commune&quot;, col_of_interest = active_population) |&gt; as.data.frame() expected_value &lt;- read.csv(&quot;test_data_communes.csv&quot;) expect_equal(returned_value, expected_value) }) test_that(&quot;selecting one commune works&quot;, { returned_value &lt;- clean_unemp( unemp, year_of_interest = 2013, place_name_of_interest = &quot;Kayl&quot;, col_of_interest = active_population) |&gt; as.data.frame() expected_value &lt;- as.data.frame( list(&quot;year&quot; = 2013, &quot;place_name&quot; = &quot;Kayl&quot;, &quot;level&quot; = &quot;Commune&quot;, &quot;active_population&quot; = 3863)) expect_equal(returned_value, expected_value) }) test_that(&quot;wrong commune name&quot;, { returned_value &lt;- clean_unemp( unemp, year_of_interest = 2013, place_name_of_interest = &quot;Paris&quot;, col_of_interest = active_population) |&gt; as.data.frame() expected_value &lt;- as.data.frame( list(&quot;year&quot; = numeric(0), &quot;place_name&quot; = character(0), &quot;level&quot; = character(0), &quot;active_population&quot; = numeric(0))) expect_equal(returned_value, expected_value) }) test_that(&quot;wrong commune name: warning is thrown&quot;, { expect_warning({ clean_unemp( unemp, year_of_interest = 2013, place_name_of_interest = &quot;Paris&quot;, col_of_interest = active_population) }, &quot;This is likely&quot;) }) Once you’re done, commit and push your changes. You should now have a pretty good intuition about unit tests. As you can see, unit tests are not just useful to make sure that changes that get introduced in our functions don’t result in regressions in our code, but also to actually improve our code. Writing unit tests allows us to fill the shoes of our users and rethink our code. A little sidenote before continuing; you might want to look into code coverage using the {covr} package. This package helps you identify code from your package that is not tested yet. The goal of course being to improve the coverage as much as possible! Take a look at {cover}’s website to learn more. Ok, one final thing; let’s say that we’re happy with our package. To actually use it in other projects we have to install it to our library. To do so, make sure RStudio is inside the right project, and press CTRL-SHIFT-B. This will install the package to our library. "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
